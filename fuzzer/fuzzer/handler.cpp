#include "handler.h"
#include "common/logger.h"
#include "common/store.h"
#include "mocker.h"
#include "thread-pool.h"
#include "ui.h"
#include "utils.h"

#include "shared-data/shared-data.h"
using namespace shm;

#include <boost/filesystem.hpp>
#include <boost/lockfree/spsc_queue.hpp>
namespace fs = boost::filesystem;
namespace bl = boost::lockfree;

#include <algorithm>
#include <ctime>
#include <iostream>
#include <iterator>
#include <map>
#include <memory>
#include <queue>
#include <set>
using namespace std;

namespace fuzz {

bool FuzzerHandler::has_more_cases() {
  return generated_testcases < max_num_testcases;
}

void FuzzerHandler::initialize() {
  current_testcase_id.store(0);
  generated_testcases.store(0);
  number_isolated_testcases.store(0);

  max_num_testcases = vm["max-num-testcases"].as<uint64_t>();
  LOG(INFO) << "Maximum number of testcases: " << max_num_testcases;

  driver = std::unique_ptr<FuzzerDriver>(new FuzzerDriver(memory));
  seeds = std::unique_ptr<SeedHandler>(new SeedHandler(memory));

  disable_ui = vm["disable-ui"].as<bool>();

  // The size of the population to use as the median. We'll allow for
  // deviation
  const uint32_t supplied_population_size =
      vm["population-initial-size"].as<uint32_t>();
  const uint32_t population_deviation =
      vm["population-deviation-size"].as<uint32_t>();

  // Create the random number
  if (vm.count("rand-seed")) {
    driver->random = std::unique_ptr<utils::Rand>(
        new utils::Rand(vm["rand-seed"].as<uint32_t>()));
  } else {
    driver->random =
        std::unique_ptr<utils::Rand>(new utils::Rand(std::time(0)));
  }

  if (vm.count("fake-target-call")) {
    skip_calling_target = vm["fake-target-call"].as<bool>();
    if (skip_calling_target) {
      LOG(INFO) << "No actual call to the SUT will be performed due to the "
                   "--fake-target-call options";
    }
  }

  if (!skip_calling_target) {
    // When we skip the call target, for testing, there is no need to
    // instantiate the commander and shared memory reader.
    commander = std::unique_ptr<Commander>(new Commander(vm, command_line));
    shm_handler = std::unique_ptr<SHMFuzzerHandler>(
        new SHMFuzzerHandler(/*cleanup*/ true));
  } else {
    mocker = std::unique_ptr<Mocker>(new Mocker(driver->random));
  }

  // Load the seeds if they are supplied. Otherwise create random ones.
  if (vm.count("seeds")) {
    LOG(INFO) << "Loading seeds from: " << vm["seeds"].as<string>();
    if (!seeds->parse(vm["seeds"].as<string>())) {
      LOG(ERROR) << "Cannot parse the seed file";
      exit(0);
    }
  } else {
    LOG(ERROR) << "No seed. Starting with random individuals.";
  }

  // Load the models that were generated by the instrumentation phase
  if (vm.count("models")) {
    const string models_file = vm["models"].as<string>();
    LOG(INFO) << "Loading models from: " << models_file;
    fs::path fd(models_file);
    if (fs::is_regular_file(fd)) {
      driver->knowledge =
          std::unique_ptr<ProgramKnowledge>(new ProgramKnowledge(fd.string()));
    } else {
      LOG(ERROR) << "The specified files of models does not exist.";
    }
  } else {
    LOG(INFO) << "No models specified. We'll go blindly...";
  }
  if (!driver->knowledge) {
    driver->knowledge =
        std::unique_ptr<ProgramKnowledge>(new ProgramKnowledge(/*mock*/ true));
  }

  //
  init_seeds(supplied_population_size - seeds->values.size(),
             population_deviation);

  // Create the initial population from the seeds
  driver->population =
      std::unique_ptr<ga::Population>(new ga::Population(seeds->values));

  // Instantiate our GA
  auto population_range = std::make_pair<size_t, size_t>(
      supplied_population_size - population_deviation,
      supplied_population_size + population_deviation);

  LOG(INFO) << "During the GA, the number of individuals will flow inside "
            << population_range;

  driver->evolver = std::unique_ptr<ga::Evolver>(
      new ga::Evolver(vm, supplied_population_size, population_range, memory,
                      driver->population, driver->random));
}

void FuzzerHandler::init_seeds(const uint32_t remaining_places,
                               const uint32_t population_deviation) {
  // Use a random initialization, that's really not the best thing to do...
  uint32_t random_seeds = remaining_places;
  if (driver->random->next_bool()) {
    random_seeds += driver->random->next_number(population_deviation);
    LOG(INFO) << "Randomly inserting new seeds... Starting with a size of "
              << random_seeds << " individuals";
  }

  // Nothing to do...
  if (random_seeds < 1)
    return;

  uint32_t inital_buffer_bytes = vm["initial-buffer-size"].as<uint32_t>();
  uint32_t inital_buffer_deviation_bytes =
      vm["initial-buffer-deviation-size"].as<uint32_t>();

  for (uint32_t i = 0; i < random_seeds; i++) {
    const uint32_t i_size =
        driver->random->next_number(inital_buffer_deviation_bytes) +
        inital_buffer_bytes;

    ga::Individual ind(memory);
    MemoryManager::triplet_t t = memory.create(i_size);
    ind.index = t.index;
    uint8_t *buffer = t.ptr;
    for (uint32_t j = 0; j < i_size; j++) {
      buffer[j] = driver->random->next_char();
    }
    seeds->values.push_back(ind);
  }
}

void FuzzerHandler::start() {
  if (command_line.empty()) {
    LOG(ERROR) << "Empty command line...";
    return;
  }
  initialize();

  // Create the monitoring thread
  FuzzerMonitor monitor(*this);
  FuzzerStats stats(*this);

  FuzzerUI ui(*this, vm["ui-port"].as<uint32_t>(),
              vm["ui-docroot"].as<string>(), vm["idir"].as<string>(),
              disable_ui);
  handler_ui = &ui;

  boost::thread monitoring_thread(boost::ref(monitor));
  boost::thread ui_thread(boost::ref(ui));

  boost::thread *stats_thread = nullptr;
  if (vm["dump-statistics"].as<bool>()) {
    stats_thread = new boost::thread(boost::ref(stats));
  }

  const uint32_t num_threads = vm["concurrency"].as<uint32_t>();
  LOG(INFO) << "Creating threadpool with " << num_threads << " threads";
  LOG(INFO) << "Target command line: " << command_line;

  // At the beginning, we start only with the seeds and learn from the
  // the behavior of the program.
  driver->init_population();

  if (num_threads == 1) {
    single_threaded_loop();
  } else {
    // Special case the multi-threaded run since there is a need for
    // synchronization
    LOG(ERROR) << "Multi-threading is not implemented yet.";
    exit(0);
    multi_threaded_loop(num_threads);
  }

  monitoring_thread.join();

  if (stats_thread != nullptr)
    stats_thread->join();

  ui_thread.join();
}

void FuzzerProcessMonitor::operator()() {
  std::unique_ptr<Commander> &commander = fuzzer_handler.commander;
  CommanderProcesses &processes = commander->processes();

  while (true) {
    if (processes.empty()) {
      if (all_testscases_received.load() && !all_testscases_sent.load()) {
        all_testscases_sent.store(true);
      }
      boost::this_thread::sleep(boost::posix_time::milliseconds(100));
      continue;
    }

    const auto pids = processes.get_terminated_processes();
    if (pids.empty())
      continue;

    // For each finished process we can get the trace and add it
    for (auto &m_pid : pids) {
      const uint64_t testcase_id = commander->get_testcase_id(m_pid.first);
      if (testcase_id < 1)
        continue;

      if (m_pid.second == E_PROCESS_TIMEDOUT) {
        // Communicate the timeout for this process...
        // LOG(INFO) << "Push testcase " << testcase_id << " as timedout";
        timed_out_queue.push(testcase_id);
        all_processed.insert(testcase_id);
      } else {
        // LOG(INFO) << "Push testcase " << testcase_id;
        queue.push(testcase_id);
        all_processed.insert(testcase_id);
      }
      commander->processed_pid(m_pid.first);
    }
  }
}

void FuzzerProcessMonitor::clear() {
  all_processed.clear();
  all_testscases_sent.store(false);
  all_testscases_received.store(false);
}

void FuzzerTraceRetriever::operator()() {
  std::unique_ptr<Commander> &commander = fuzzer_handler.commander;
  bool empty_queue;
  uint64_t testcase_id;

  while (true) {
    empty_queue = true;

    // Get a testcase id from the queue
    if (queue.try_pop(testcase_id)) {
      empty_queue = false;
      all_received.insert(testcase_id);
      process(testcase_id);
    }

    if (timed_out_queue.try_pop(testcase_id)) {
      empty_queue = false;
      all_received.insert(testcase_id);
      try {
        // shm_handler->container->remove_trace(testcase_id);
        ++processed_testcases;
        all_processed.insert(testcase_id);
      } catch (exception &e) {
        ++processed_testcases;
        all_processed.insert(testcase_id);
        continue;
      }
    }

    if (empty_queue) {
      boost::this_thread::sleep(boost::posix_time::milliseconds(100));
      continue;
    }
  }
}

bool FuzzerTraceRetriever::process(const uint64_t testcase_id) {
  LOG(INFO) << "FuzzerTraceRetriever::process- receives " << testcase_id;

  if (testcase_id < 1) {
    LOG(INFO) << "Non-valid testcase_id " << testcase_id;
    return true;
  }

  Container::trace_t *trace = shm_handler->container->get_trace(testcase_id);
  if (trace) {
    try {
      // LOG(INFO) << "Add trace for " << testcase_id;
      fuzzer_handler.driver->knowledge->add_trace(testcase_id, *trace);
      // LOG(INFO) << " Remove SHM trace for " << testcase_id;
      // shm_handler->container->remove_trace(testcase_id);
      LOG(INFO) << "Processed testcase_id=" << testcase_id;
      ++processed_testcases;
      all_processed.insert(testcase_id);
    } catch (exception &e) {
      LOG(ERROR) << "FuzzerTraceRetriever::process- Exception: " << e.what();
    }
    return true;
  } else {
    LOG(INFO) << "Cannot retrieve trace for testcase_id=" << testcase_id;
    return false;
  }
}

void FuzzerTraceRetriever::clear() {
  processed_testcases.store(0);
  all_processed.clear();
  all_received.clear();
  all_testscases_sent.store(false);
  all_testscases_received.store(false);
}

void FuzzerHandler::clear_queue(testcase_queue_t &queue) {
  LOG(INFO) << "Clear queue...";
  uint64_t testcase_id;
  while (queue.try_pop(testcase_id))
    ;
}

void FuzzerHandler::single_threaded_loop() {
  testcase_queue_t available_testcases;
  testcase_queue_t timedout_testcases;

  const double one_evolution_timeout_seconds =
      (double)(vm["evolution-timeout-seconds"].as<uint32_t>());
  const size_t max_concurrent_processes = vm["max-num-processes"].as<size_t>();

  FuzzerProcessMonitor process_monitor(*this, available_testcases,
                                       timedout_testcases);
  FuzzerTraceRetriever trace_retriever(*this, available_testcases,
                                       timedout_testcases);

  FuzzerCrashAnalyzer crash_analyzer(*this, vm["idir"].as<string>(),
                                     vm["target-symbols"].as<string>());

  boost::thread crash_analyzer_thread(boost::ref(crash_analyzer));
  boost::thread process_thread(boost::ref(process_monitor));
  boost::thread trace_thread(boost::ref(trace_retriever));

  CommanderProcesses &processes = commander->processes();

  bool skip_evolution = true;
  while (has_more_cases()) {
    driver->one_generation(skip_evolution);
    skip_evolution = false;

    // Remove previously computed scores...
    driver->knowledge->reset_scores();
    commander->clear();
    process_monitor.clear();
    trace_retriever.clear();

    // Just make sure it's all clean here!
    // clear_queue(available_testcases);
    // clear_queue(timedout_testcases);

    // iterate over all current individual and create processes for each
    // of them
    size_t to_process = driver->population->individuals.size();
    set<uint64_t> current_testcase_ids;

    for (ga::Individual &current_individual : driver->population->individuals) {
      while (processes.num_pids() >= max_concurrent_processes) {
        boost::this_thread::sleep(boost::posix_time::milliseconds(1));
      }

      // Assign the testcase id
      ++current_testcase_id;
      ++generated_testcases;
      if (current_individual.id < 1) {
        current_individual.id = current_testcase_id;
      }

      if (!disable_ui)
        handler_ui->push_testcase(current_individual.toShared());

      LOG(INFO) << current_individual.toString();

      if (skip_calling_target) {
        Container::mocked_trace_t mocked =
            mocker->generate_random_trace(current_testcase_id);
        driver->knowledge->add_trace(current_testcase_id, mocked);
        current_testcase_ids.insert(current_testcase_id);
      } else {
        // Actually perform the call
        if (!commander->call(current_testcase_id, current_individual)) {
          LOG(ERROR) << "Couldn't make call for testcase "
                     << current_testcase_id;
          // We know we couldn't make a call for this guy, so we remove it
          // from the total count
          --to_process;
        } else {
          current_testcase_ids.insert(current_testcase_id);
        }
      }
    }

    if (!skip_calling_target) {
      process_monitor.all_testscases_received.store(true);
      while (!process_monitor.all_testscases_sent.load()) {
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        LOG(INFO) << "Waiting for all testcases to be sent...";
      }

      LOG(INFO) << "FuzzerProcessMonitor sent "
                << process_monitor.all_processed.size() << " testcases, vs. "
                << to_process << " generated (though, current_testcase_id="
                << current_testcase_ids.size() << ")";

      LOG(INFO) << "Sent to trace_receiver the testcases := "
                << process_monitor.all_processed;

      trace_retriever.all_testscases_received.store(true);

      // Wait for the completion of the trace_retriever
      while (trace_retriever.processed_testcases.load() < to_process) {
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        LOG(INFO) << "Awaiting completion, processed = "
                  << trace_retriever.processed_testcases.load()
                  << " but expecting " << to_process;

        LOG(INFO) << "All sent? " << trace_retriever.all_testscases_sent.load();
        if (!trace_retriever.all_testscases_sent.load()) {
          LOG(INFO) << "Sent to knowledge/evolution the testcases := "
                    << trace_retriever.all_processed;
          LOG(INFO) << " Size := " << trace_retriever.all_processed.size();
          LOG(INFO) << " Received Size := "
                    << trace_retriever.all_received.size();
          // Difference
          std::set<uint64_t> result;
          std::set_difference(trace_retriever.all_processed.begin(),
                              trace_retriever.all_processed.end(),
                              process_monitor.all_processed.begin(),
                              process_monitor.all_processed.end(),
                              std::inserter(result, result.end()));
          LOG(INFO) << "Difference := " << result;
        }
      }

      LOG(INFO) << "All processes are accounted for.";

      // reset_shared_memory(&trace_retriever);

      // Communicate the coverage for this run to the UI
      if (!disable_ui) {
        handler_ui->consume_local_coverage(
            driver->knowledge->get_local_coverage());

        // Gather all crashing testcase IDs
        set<uint64_t> crashing_testcase_ids;
        for (auto &tc_id : current_testcase_ids) {
          if (crash_analyzer.crash_analyzer.is_crashing(tc_id)) {
            crashing_testcase_ids.insert(tc_id);
          }
        }

        if (!crashing_testcase_ids.empty()) {
          handler_ui->set_crashing_testcase_ids(crashing_testcase_ids);
        }

        driver->population->assign_best_ro();
      }
    }

    LOG(INFO) << "Graph stats. Vertices="
              << driver->knowledge->coverage_size().first
              << " Edges=" << driver->knowledge->coverage_size().second;
  }
  process_thread.join();
  trace_thread.join();
  crash_analyzer_thread.join();
}

void FuzzerHandler::reset_shared_memory(FuzzerTraceRetriever *trace_retriever) {
  LOG(ERROR) << "Had to reset the shared memory due to timeouts";
  shm_handler.reset(new SHMFuzzerHandler(/*cleanup*/ true));
  boost::this_thread::sleep(boost::posix_time::seconds(1));
  trace_retriever->shm_handler.reset(new SHMRuntimeWriter());
  boost::this_thread::sleep(boost::posix_time::seconds(1));
}

void FuzzerHandler::multi_threaded_loop(const uint32_t num_threads) {
  using namespace threading;

  threadpool_t pool(num_threads);
  while (true) {
    if (!has_more_cases()) {
      break;
    }

    if (pool.is_full()) {
      boost::this_thread::sleep(boost::posix_time::microseconds(10));
      continue;
    }

    pool.enqueue([&] {
      try {
        bool error = false;
        if (!error) {
          ++current_testcase_id;

          ++generated_testcases;
        }
      } catch (exception &e) {
        LOG(ERROR) << "Exception: " << e.what();
      }
      pool.one_avail();
    });
  }
}

// Perform a single loop for testing the given binary. We gather the result in
// term
// of trace and score for the given input. That's helpful to debug the behavior
// of
// the scoring mechanism against known inputs.
measure::trace_score_t
FuzzerHandler::isolated_evaluation(const std::string &input_buffer) {
  const uint64_t input_testcase_id = ++current_testcase_id;
  const size_t length = input_buffer.length();
  uint8_t *raw_buffer =
      reinterpret_cast<uint8_t *>(const_cast<char *>(input_buffer.c_str()));

  const size_t current_num_isolated = ++number_isolated_testcases;
  if (current_num_isolated >= 500)
    return measure::trace_score_t();

  isolated_testcases[current_num_isolated] = input_testcase_id;
  Commander local_commander(vm, command_line, /*no_cleanup*/ true);
  measure::trace_score_t result;

  if (local_commander.call(input_testcase_id, raw_buffer, length)) {
    // wait for having access to this very testcase...
    while (true) {
      boost::this_thread::sleep(boost::posix_time::microseconds(10));
      Container::trace_t *trace =
          isolated_shm_handler.container->get_trace(input_testcase_id);
      if (trace) {
        result = driver->knowledge->evaluate_trace(input_testcase_id, *trace);
        isolated_shm_handler.container->remove_trace(input_testcase_id);
        break;
      }
    }
    isolated_testcases[current_num_isolated] = 0;
    number_isolated_testcases--;
  }

  return result;
}

bool FuzzerHandler::is_isolated_testcase(const uint64_t testcase_id) const {
  if (number_isolated_testcases < 1)
    return false;
  for (size_t i = 0; i < number_isolated_testcases; i++) {
    if (isolated_testcases[i] == testcase_id)
      return true;
  }
  return false;
}

//
// FuzzerDriver
//
void FuzzerDriver::init_population() {
  if (!population->seeds.empty()) {
    for (auto &individual : population->seeds) {
      population->individuals.push_back(individual);
    }
  } else {
    LOG(ERROR) << "There was no seeds...";
  }
}

void FuzzerDriver::one_generation(bool skip_evolution) {
  if (skip_evolution) {
    // This is just the dry run where we have all seeds in. Let's just use them
    // as is.
    LOG(INFO) << "Skipped generation.";
    return;
  }

  LOG(INFO) << "Create a new generation of testcases";
  evolver->evolve(knowledge);
}

//
// Monitor
//
void FuzzerMonitor::operator()() {
  uint64_t num_seconds = 0;

  while (true) {
    boost::this_thread::sleep(boost::posix_time::seconds(1));
    num_seconds++;

    const uint64_t current_gen_testcases =
        fuzzer_handler.generated_testcases.load();
    // do something
    LOG(INFO) << "[Monitor] Elapsed time: " << fuzzer_handler.timer.seconds()
              << " seconds";
    LOG(INFO) << "[Monitor] Generated testcases: " << current_gen_testcases
              << ", rate: " << (current_gen_testcases / num_seconds) << "/s. "
              << "Currently at " << fuzzer_handler.driver->evolver->generations
              << "th generation";
  }
}

//
// UI
//
FuzzerUI::FuzzerUI(FuzzerHandler &fuzzer_handler, const uint32_t port,
                   const string &docroot_str, const string &data_store_str,
                   const bool disable_ui)
    : fuzzer_handler(fuzzer_handler), disable_ui(disable_ui) {

  if (!disable_ui) {
    server = std::unique_ptr<ui::WebSocketServer>(new ui::WebSocketServer(
        fuzzer_handler, port, docroot_str, data_store_str));
  }
}

void FuzzerUI::operator()() {
  if (disable_ui) {
    cout << "No UI for this run..." << endl;
    while (true) {
      boost::this_thread::sleep(boost::posix_time::seconds(60));
    }
    return;
  }

  FuzzerUIQueueReader queue_reader(*this);
  boost::thread queue_thread(boost::ref(queue_reader));

  FuzzerUICrashReader crash_reader(*this, server->crash_reader.get());
  boost::thread crash_thread(boost::ref(crash_reader));

  cout << "Starting UI: http://localhost:" << server->port << endl;
  server->start();
  crash_thread.join();
  queue_thread.join();
}

void FuzzerUI::push_testcase(const ga::ShareableIndividual &ind) {
  testcase_queue.push(ind);
}

void FuzzerUI::consume_local_coverage(
    const std::map<instr::element_id, uint32_t> coverage) {
  coverage_queue.push(coverage);
}

void FuzzerUI::set_crashing_testcase_ids(
    const std::set<uint64_t> &testcase_ids) {
  crashing_queue.push(testcase_ids);
}

void FuzzerUIQueueReader::operator()() {
  individual_queue_t &testcase_queue = fuzzer_ui.testcase_queue;
  coverage_queue_t &coverage_queue = fuzzer_ui.coverage_queue;
  crashing_queue_t &crashing_queue = fuzzer_ui.crashing_queue;

  ui::UIDataStore *data_store = nullptr;
  ui::UIStoreGraph *store_graph = nullptr;
  ui::UICrashSummarization *crash_summary = nullptr;

  while (true) {
    if (testcase_queue.empty() && coverage_queue.empty() &&
        crashing_queue.empty()) {
      boost::this_thread::sleep(boost::posix_time::microseconds(10));
      continue;
    }

    if (data_store == nullptr) {
      if (fuzzer_ui.server->errored || !fuzzer_ui.server->data_store) {
        LOG(ERROR) << "UI is not properly started";
        boost::this_thread::sleep(boost::posix_time::microseconds(10));
        continue;
      } else {
        data_store = fuzzer_ui.server->data_store.get();
      }
    }

    if (store_graph == nullptr) {
      if (fuzzer_ui.server->errored || !fuzzer_ui.server->store_graph) {
        LOG(ERROR) << "UI is not properly started";
        boost::this_thread::sleep(boost::posix_time::microseconds(10));
        continue;
      } else {
        store_graph = fuzzer_ui.server->store_graph.get();
      }
    }

    if (crash_summary == nullptr) {
      if (fuzzer_ui.server->errored || !fuzzer_ui.server->crash_summary) {
        LOG(ERROR) << "UI is not properly started";
        boost::this_thread::sleep(boost::posix_time::microseconds(10));
        continue;
      } else {
        crash_summary = fuzzer_ui.server->crash_summary.get();
      }
    }

    if (!testcase_queue.empty()) {
      ga::ShareableIndividual ind;
      if (testcase_queue.pop(ind)) {
        if (!data_store->set(ind.id, ind)) {
          LOG(ERROR)
              << "Cannot insert testcase in store, adding it back to the queue";
          testcase_queue.push(ind);
        }
      }
    }

    if (!coverage_queue.empty()) {
      coverage_t local_coverage;
      if (coverage_queue.pop(local_coverage)) {
        store_graph->update_coverage(local_coverage);
      }
    }

    if (!crashing_queue.empty()) {
      std::set<uint64_t> crashing_ids;
      if (crashing_queue.pop(crashing_ids)) {
        crash_summary->update_crashers(crashing_ids);
      }
    }
  }
}

void FuzzerUICrashReader::operator()() {
  while (true) {
    boost::this_thread::sleep(boost::posix_time::seconds(1));
    crash_reader->run();
  }
}

//
// Stats
//
void FuzzerStats::operator()() {
  while (true) {
    boost::this_thread::sleep(boost::posix_time::seconds(1));
    LOG(INFO) << "[Statistics] dump...";
    LOG(INFO) << " [+] Best scores ["
              << fuzzer_handler.driver->population->best_individuals.min_key
              << ","
              << fuzzer_handler.driver->population->best_individuals.max_key
              << "]";
  }
}

void FuzzerStats::compute_overall_fitness() {}

//
// CrashAnalyzer
//
void FuzzerCrashAnalyzer::operator()() {
  while (true) {
    boost::this_thread::sleep(boost::posix_time::seconds(1));
    crash_analyzer.run();
  }
}
}
