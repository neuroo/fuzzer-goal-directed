#ifndef STORE_H
#define STORE_H

#include <map>
#include <memory>
#include <string>

#include "elements.h"

// XXX consider moving to Protocol Buffer since it has clients for
//     C++, Java, and Python. Might be better for interoperability.
#include <cereal/archives/binary.hpp>
#include <cereal/types/list.hpp>
#include <cereal/types/map.hpp>
#include <cereal/types/memory.hpp>
#include <cereal/types/string.hpp>
#include <cereal/types/vector.hpp>

CEREAL_REGISTER_TYPE(instr::SourceElement);
CEREAL_REGISTER_TYPE(instr::FunctionElement);
CEREAL_REGISTER_TYPE(instr::BlockElement);
CEREAL_REGISTER_TYPE(instr::SummaryElement);
CEREAL_REGISTER_TYPE(instr::ConditionElement);

namespace instr {

// XXX should move to a std::unique_ptr for better performances instead of
//     a std::shared_ptr, then we have to use the move semantics in the entire
//     lib
typedef std::map<element_id, std::shared_ptr<Element>> lookup_t;
typedef std::map<std::string, element_id> sources_t;

// This is the internal state that gets serialized.
struct StoreImpl {
  element_id global_id = ERROR_ID;
  sources_t sources;
  lookup_t elements;

  StoreImpl() = default;

  StoreImpl(const StoreImpl &impl)
      : global_id(impl.global_id), sources(impl.sources),
        elements(impl.elements) {}

  ~StoreImpl() = default;

  // Get the next ID
  element_id getNextId() {
    global_id++;
    return global_id;
  }

  element_id addSource(const std::string &sourceName);

  void add(const element_id id, const std::shared_ptr<Element> &element);

  //
  // Serialization utils
  //
  template <class Archive> void serialize(Archive &archive) {
    archive(global_id, sources, elements);
  }

  std::string toString() const;

  //
  // I/O
  //
  static StoreImpl fromFile(const std::string &serFileName);

  static bool toFile(const std::string &serFileName, const StoreImpl &s);
};

// The store is used to communicate intelligible information
// captured from the runtime. It's generated by the instrumentation
// pass. For each TU, the store is entirely serialized/deserialized
// into a binary representation.
class Store {
  std::string serFileName;
  StoreImpl s;

public:
  Store(const std::string &_serFileName);

  Store() = delete;
  Store(const Store &store) = delete;
  Store &operator=(const Store &s) = delete;

  ~Store();

  element_id getNextId() { return s.getNextId(); }

  StoreImpl &store() { return s; }

  std::string toString() const { return s.toString(); }

  static std::shared_ptr<Element> create(const Element::Kind kind,
                                         const element_id id,
                                         const element_id parent_id = ERROR_ID);
};
}

#endif
